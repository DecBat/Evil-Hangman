# Evil-Hangman
Semester long Computing 2 project focused on creating Evil Hangman in C

Evil Hangman is a clever and challenging variation of the traditional Hangman game. Unlike the standard version, where the computer selects a single word at the beginning and the player tries to guess it letter by letter, Evil Hangman changes the rules to work against the player. At the start of the game, the computer doesn’t choose one specific word. Instead, it keeps a large set of possible words that match the desired word length. Each time the player makes a guess, the computer examines all the words in its current list and partitions them into groups based on how the guessed letter would appear in those words (or not appear at all).

For example, if the player guesses the letter 'e', the computer splits the list into "word families"—groups where the position of 'e' varies, including words that don’t have 'e' at all. The computer then chooses the largest group among these, preferably the one that avoids revealing the letter to the player. This approach allows the computer to delay revealing letters for as long as possible, making the game much harder. By constantly shifting the possible word list to keep its options open, Evil Hangman gives the illusion that the computer is playing fairly, while actually dodging the player’s guesses until the word is eventually forced to reveal itself or the player runs out of chances.

To implement Evil Hangman in C, several tactics are used to manage dynamic data and efficiently manipulate word lists. One of the key strategies involves storing the dictionary words in a dynamic data structure, such as a generic vector or an AVL Tree, and filtering this list based on the player’s guesses. Each time the player makes a guess, the program generates "word families" by grouping words based on a pattern—called a key—that shows the guessed letter's positions in the word (or lack thereof). For example, if the guessed letter is 'a' and a word is "apple", its key would be "a____"; if a word is "brick", the key would be "_____" because it has no 'a'. A map-like data structure, such as a binary search tree, is used to associate these keys with corresponding word groups.

After grouping, the largest word family is selected to maximize ambiguity, ideally one that doesn’t reveal the guessed letter. This selection process often involves counting and comparing group sizes. Memory management is also a major concern in C, so functions must carefully allocate, free, and resize memory when building and updating the word list and keys. Since C lacks native support for higher-level abstractions, one must create custom string and vector implementations to handle operations like string comparison, dynamic resizing, and pattern generation. These tactics work together to ensure the program adapts in real time, maintaining the illusion of fairness while making it as difficult as possible for the player to win.
